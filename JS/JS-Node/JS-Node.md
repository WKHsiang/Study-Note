# JS

## 1. JS中的数据类型

### 原始类型

1. string

2. number

> 数字类型可以在前面加上前缀，来表示不同的进制
> 0：表示8进制
> 0x：表示16进制
> 0b：表示2进制

3. boolean

4. null

> js的bug： typeof null，得到的是object

5. undefined

### 引用类型

1. Object

- 可以认为，对象是由多个基本类型组成

2. Function

## 2. 变量

变量是一块内存空间，用于保存数据

> 计算机：CPU、内存、硬盘、输入输出设备
> 内存：存取速度快，数据易丢失
> 硬盘：存取速度慢，数据永久保存
> 计算机程序的运行，仅与内存打交道

### 如何使用变量

1. 声明变量
```javascript
let a = 1
```
2. 标识符规范

1) [必须]只能以英文字母、下划线、$开头

2) [必须]其他位置可以出现数字、英文字母、下划线、$

3) [可选]命名需要做到望文知义

4) [可选]多个单词，使用驼峰命名法，单词首字母大写，目前使用的都是小驼峰命名法

同名变量，提升后变成一个

### 全局对象

JS大部分的宿主环境，都会提供一个特殊的对象，该对象可以直接在JS代码中访问，该对象叫作全局对象

在浏览器环境中，全局对象为window，表示整个窗口

全局对象中的所有属性，可以直接使用，而不需要写上全局变量名。

**开发者定义的所有变量，实际上，会成为window对象的属性。**

**如果变量没有被赋值，则该变量不会覆盖window对象上的同名属性。**

## 引用类型

**原始类型的变量，存放的是具体的值**

**引用类型的变量，存放的是内存地址**

## 3. 运算符

### 优先级

从高到低：
1. ```++ --```
2. ```* / %```
3. ```+ -```

优先级的运算细节：

1. 从左到右依次查看
2. 若遇到操作数，将数据的值直接取出
3. 若遇到相邻的两个运算符，并且左边的运算符优先级大于等于右边的运算符，则直接运算左边的运算符

## 3-1. 比较运算符

大小比较： >   <   >=   <=

想等比较：== === != !==

**算术运算符的优先级高于比较运算符**


## 3-2. 大小比较

### 细节

1. 两个字符串比较大小，比较的是字符串的字符编码

2. 若其中一个不是字符串，并且两个都是原始类型，将他们都转化为数字进行比较

NaN与任何数字比较，结果都是false

Infinity比任何数字都大

-Infinity比任何数字都小

3. 若其中一个是对象，将对象转换为原始类型后，按照规则1或规则2进行比较

目前，对象转换为原始类型后，是字符串'[Object Object]'

undefined转化为数字：NaN

## 3-3. 相等比较

### 细节

1. 两端的类型，直接比较两个数据本身是否相等（两个对象比较的是地址）

2. 两端的类型不同

1). null和undefined，它们相等（null == undefined），与其它值都不相等
2). 其他原始类型，比较时先转化为数字，再进行比较
3). NaN不等于任何数字，包括其自身
4). Infinity和-Infinity，只能和自身相等
5). 对象比较时，要先转换为原始类型，再进行比较                                                                                                                                                 **由于相等和不相等比较，对于不同类型的数据比较违反直觉，因此，通常我们不使用这种比较方式，而是使用更加接近直觉的严格相等和严格不相等比较**

## 3-4. 逻辑运算符

&&   ||   !

## 4. 数字的存储

**在对精度要求很高的系统中，或要对小树的运算结果进行比较时，需要特别谨慎**

### 二进制

现实世界中，使用的是十进制，10个数字，逢十进一

计算机世界中，二进制，2个数字，逢二进一

#### 整数转换

二进制 -> 十进制

1101 -> $1*2^3 + 1*2^2 + 0*2^1 + 1*2^0 = 13$

11.01 -> $1*2^1 + 1*2^0 + 0*2^{-1} + 1*2^{-2} = 3.25$

十进制 -> 二进制

13 -> 1101

```
13 / 2 商 6 余 1
6  / 2 商 3 余 0
3  / 2 商 1 余 1
1  / 2 商 0 余 1
```

3.25 -> 11.01

整数部分一样

小数部分

```
0.25 * 2 0.5 整数部分：0

0.5  * 2 1.0 整数部分：1

乘的时候只管小数部分，整数部分去掉，小数部分是0时停止
```
整数部分从上往下看

### 为什么JS的小数运算不精确

十进制的小数，转换为二进制后，可能是无限小数，但是计算机对数字的存储能力有限，因此会丢失一些数据

### JS如何存储数字

整数法、浮点法

JS中，存储的所有数字，都按照浮点法存放

浮点法存放的数字，叫做浮点数(float)，浮点数分为单精度和双精度

JS中，使用双精度存放浮点数，IEEE 754

**存放方式**

JS在计算机中，给每个数字开辟一块内存空间，尺寸固定为64位
> 在计算机中，位(bit)是最小的存储单位，简称为bit
> 1 byte = 8 bit
> 1KB = 1024byte
> 1MB = 1024KB
> 1GB = 1024MB
```
[第1段][第2段][第3段]

第1段：1位，表示符号位，如果为1，是负数，如果为0，是正数
第2段：11位，表示指数位，这里的指数是2为底的指数，而不是10
第3位：52位，表示有效数字
```
## 5. 流程图

一套标准的图形，用于描述程序的逻辑

通常用流程图分析程序的流程

> markdiwn中粘贴图片， ctrl + alt + v

## 6. 数组

### 添加数组项

- push(数据)：向数组末尾添加一个数据
- unshift(数据)：向数据起始位置添加一个数据，会导致数组每一项的下标向后移动
- splice(下标，0，添加的数据)：从指定下标位置开始，删除0个，然后在该位置插入添加的数据，如果下标超过范围，则按照范围的边界进行处理

### 删除数据

- delete 这种做法会产生稀松数组，所以不推荐使用该做法
- pop()：删除数组的最后一项，该表达式返回最后一项的数据
- shift()：删除数组第一项，该表达式返回数组第一项的值
- splice(下标，删除数量)：从下标位置开始，删除指定数量的数据，返回一个新的数组，该数组记录了被删除的数据

### 其他操作

- 截取 slice(起始位置下标，结束位置下标)：从起始位置到结束位置之间的数据拿出来，得到一个新数组，该函数不会改变原数组

下标如果是负数，则从数组末尾往前数

如果不写结束下标，则直接取到末尾

- 清空数组

arr.splice(0, arr.length)

arr.length = 0

arr = []

- 查找数组中的某一项的下标

arr.indexOf(数据) 从数组中依次查找对应的数据，查找时使用严格相等进行比较，找到第一个匹配的下标，返回，如果未找到，返回-1

arr.lastIndexOf(数据) 从数组中查找出数据最后一次出现时的最后一个下标

- arr.fill(数据)：将数组的所有项，填充为指定的数据

arr.fill(数据, 开始下标)：将数组从指定的下标起，到数组的末尾，填充为指定的数据

arr.fill(数据, 开始下标, 结束下标)：将数组从指定的下标起，到数结束下标的位置(不包含结束下标)，填充为指定的数据

arr.join(分隔符)  Array -> String

## 7. 函数语法

typeof 函数名 = 'function'

## 8. 作用域和闭包

### 作用域

作用域表示一个代码区域，也表示一个运行环境

JS中，有两种作用域：

1. 全局作用域

直接在脚本中书写的代码

在全局作用域中声明的变量，会被提升到脚本块的顶部，并成为全局对象的属性

2. 函数作用域

函数中的代码

在函数作用域中声明的变量，会被提升到函数的顶部，并且不会成为全局对象的属性，因此，函数中声明的变量不会导致全局变量的污染。

尽量把功能封装在函数中

但是，当函数成为一个表达式时，它既不会提升，也不会污染全局变量。

将函数变成一个函数表达式的方法之一，是将函数用小括号括起来。立即执行函数

### 作用域中可以使用的变量

全局作用域只能使用全局作用域中声明的变量（包括函数）

函数作用域中不仅能使用自身作用域中声明的变量（包括函数），还能使用外部环境中的变量和函数

有些时候，某个函数比较复杂，在编写的过程，可能需要另外一些函数来辅助它完成一些功能，而这些函数仅仅会被该函数使用，不会在其他位置使用，则可以将这些函数声明到该函数的内部。

### 闭包

闭包(closure)，是一种现象，内部函数，可以使用外部环境中的变量

### 函数表达式

JS中，函数也是一个数据，语法上，函数可以用于任何需要数据的地方

JS中，函数是一等公民

函数是一个引用类型，将其赋值给某个变量时，变量中保存的是函数的地址

### 构造函数

```js
new 函数名(参数)
```

构造函数专门用于创建函数

1) 函数名使用大驼峰命名法

2) 构造函数内部，会自动创建一个新对象，this指向新创建的对象，并且自动返回新对象

3) 构造函数中如果出现返回值，如果返回的是原始类型，则直接忽略；如果返回的是引用类型，则使用返回的结果

4) 所有的对象，最终都是通过构造函数创建的

### new.target

该表达式在函数中使用，返回的是当前的构造函数，但是，如果该函数不是通过new调用的，则返回undefined

通常用于判断某个函数是否是通过new在调用。

### 函数的本质

函数的本质就是对象

所有的函数都是通过```new Function```创建

> Function

由于函数本身就是对象，因此函数中，可以拥有各种属性。

### 包装类

JS为了增强原始类型的功能，为boolean、string、number分别创建了一个构造函数：

1. Boolean

2. String

3. Number

如果语法上将原始类型当做对象使用时（一般在使用属性时），JS会自动在该位置利用对应的构造函数，创建对象来访问原始类型的属性。

> 类：在JS中，可以认为类就是构造函数，但在其他语言(如JAVA)中不是

> 成员属性(方法)、实例属性(方法)：表示该属性是通过构造函数创建的对象调用的。

> 静态属性(方法)、类属性(方法)：表示该属性是通过构造函数本身调用的。

### 递归

在函数内部，直接或间接调用自身

要避免无限递归，无限递归会导致执行栈溢出

对比死循环

- 死循环不会报错，也不会导致执行栈溢出
- 无限递归会导致执行栈溢出

### 执行栈

任何代码的执行都必须有一个执行环境，执行环境为代码的执行提供支持

执行环境是放到执行栈中。

每个函数的调用，都需要创建一个函数的执行环境，函数调用结束，执行环境销毁。

执行栈有相对固定的大小，如果执行环境太多，执行栈无法容纳，会报错

### 尾递归

如果一个函数最后一条语句是调用函数，并且调用函数不是表达式的一部分，则该函数称之为尾递归。

某些语言或执行环境会对尾递归进行优化，他们会立即销毁当前函数，避免执行栈空间被占用。

## 9. 标准库（标准API）

- 库(liberary)
- API：应用程序编程接口，Application Programing Interface

### Object

#### 静态成员

- Object.keys(某个对象)，得到某个对象的所有属性名数组
- Object.values(某个对象)，得到某个对象的所有属性值数组
- Object.entries(某个对象)，得到某个对象所有属性名和属性值的数组

#### 实例成员

> 实例成员可以被重写

**所有对象，都拥有Object的所有实例成员**

- Object.toString()，得到某个对象的字符串格式

默认情况下，该方法返回"[Object Object]"

- Object.valueOf()，得到某个对象的值

默认情况下，返回该对象本身

在JS中，当自动进行类型转换时，如果要对一个对象进行转换，实际上实现调用对象的valueOf方法，然后调用对象的toString方法

### Function