# JS

## 1. JS中的数据类型

### 原始类型

1. string

2. number

> 数字类型可以在前面加上前缀，来表示不同的进制
> 0：表示8进制
> 0x：表示16进制
> 0b：表示2进制

3. boolean

4. null

> js的bug： typeof null，得到的是object

5. undefined

### 引用类型

1. Object

- 可以认为，对象是由多个基本类型组成

2. Function

## 2. 变量

变量是一块内存空间，用于保存数据

> 计算机：CPU、内存、硬盘、输入输出设备
> 内存：存取速度快，数据易丢失
> 硬盘：存取速度慢，数据永久保存
> 计算机程序的运行，仅与内存打交道

### 如何使用变量

1. 声明变量
```javascript
let a = 1
```
2. 标识符规范

1) [必须]只能以英文字母、下划线、$开头

2) [必须]其他位置可以出现数字、英文字母、下划线、$

3) [可选]命名需要做到望文知义

4) [可选]多个单词，使用驼峰命名法，单词首字母大写，目前使用的都是小驼峰命名法

同名变量，提升后变成一个

### 全局对象

JS大部分的宿主环境，都会提供一个特殊的对象，该对象可以直接在JS代码中访问，该对象叫作全局对象

在浏览器环境中，全局对象为window，表示整个窗口

全局对象中的所有属性，可以直接使用，而不需要写上全局变量名。

**开发者定义的所有变量，实际上，会成为window对象的属性。**

**如果变量没有被赋值，则该变量不会覆盖window对象上的同名属性。**

## 引用类型

**原始类型的变量，存放的是具体的值**

**引用类型的变量，存放的是内存地址**

## 3. 运算符

### 优先级

从高到低：
1. ```++ --```
2. ```* / %```
3. ```+ -```

优先级的运算细节：

1. 从左到右依次查看
2. 若遇到操作数，将数据的值直接取出
3. 若遇到相邻的两个运算符，并且左边的运算符优先级大于等于右边的运算符，则直接运算左边的运算符

## 3-1. 比较运算符

大小比较： >   <   >=   <=

想等比较：== === != !==

**算术运算符的优先级高于比较运算符**


## 3-2. 大小比较

### 细节

1. 两个字符串比较大小，比较的是字符串的字符编码

2. 若其中一个不是字符串，并且两个都是原始类型，将他们都转化为数字进行比较

NaN与任何数字比较，结果都是false

Infinity比任何数字都大

-Infinity比任何数字都小

3. 若其中一个是对象，将对象转换为原始类型后，按照规则1或规则2进行比较

目前，对象转换为原始类型后，是字符串'[Object Object]'

undefined转化为数字：NaN

## 3-3. 相等比较

### 细节

1. 两端的类型，直接比较两个数据本身是否相等（两个对象比较的是地址）

2. 两端的类型不同

1). null和undefined，它们相等（null == undefined），与其它值都不相等
2). 其他原始类型，比较时先转化为数字，再进行比较
3). NaN不等于任何数字，包括其自身
4). Infinity和-Infinity，只能和自身相等
5). 对象比较时，要先转换为原始类型，再进行比较                                                                                                                                                 **由于相等和不相等比较，对于不同类型的数据比较违反直觉，因此，通常我们不使用这种比较方式，而是使用更加接近直觉的严格相等和严格不相等比较**

## 3-4. 逻辑运算符

&&   ||   !

## 4. 数字的存储

**在对精度要求很高的系统中，或要对小树的运算结果进行比较时，需要特别谨慎**

### 二进制

现实世界中，使用的是十进制，10个数字，逢十进一

计算机世界中，二进制，2个数字，逢二进一

#### 整数转换

二进制 -> 十进制

1101 -> $1*2^3 + 1*2^2 + 0*2^1 + 1*2^0 = 13$

11.01 -> $1*2^1 + 1*2^0 + 0*2^{-1} + 1*2^{-2} = 3.25$

十进制 -> 二进制

13 -> 1101

```
13 / 2 商 6 余 1
6  / 2 商 3 余 0
3  / 2 商 1 余 1
1  / 2 商 0 余 1
```

3.25 -> 11.01

整数部分一样

小数部分

```
0.25 * 2 0.5 整数部分：0

0.5  * 2 1.0 整数部分：1

乘的时候只管小数部分，整数部分去掉，小数部分是0时停止
```
整数部分从上往下看

### 为什么JS的小数运算不精确

十进制的小数，转换为二进制后，可能是无限小数，但是计算机对数字的存储能力有限，因此会丢失一些数据

### JS如何存储数字

整数法、浮点法

JS中，存储的所有数字，都按照浮点法存放

浮点法存放的数字，叫做浮点数(float)，浮点数分为单精度和双精度

JS中，使用双精度存放浮点数，IEEE 754

**存放方式**

JS在计算机中，给每个数字开辟一块内存空间，尺寸固定为64位
> 在计算机中，位(bit)是最小的存储单位，简称为bit
> 1 byte = 8 bit
> 1KB = 1024byte
> 1MB = 1024KB
> 1GB = 1024MB
```
[第1段][第2段][第3段]

第1段：1位，表示符号位，如果为1，是负数，如果为0，是正数
第2段：11位，表示指数位，这里的指数是2为底的指数，而不是10
第3位：52位，表示有效数字
```
## 5. 流程图

一套标准的图形，用于描述程序的逻辑

通常用流程图分析程序的流程

> markdiwn中粘贴图片， ctrl + alt + v

## 6. 数组

### 添加数组项

- push(数据)：向数组末尾添加一个数据
- unshift(数据)：向数据起始位置添加一个数据，会导致数组每一项的下标向后移动
- splice(下标，0，添加的数据)：从指定下标位置开始，删除0个，然后在该位置插入添加的数据，如果下标超过范围，则按照范围的边界进行处理

### 删除数据

- delete 这种做法会产生稀松数组，所以不推荐使用该做法
- pop()：删除数组的最后一项，该表达式返回最后一项的数据
- shift()：删除数组第一项，该表达式返回数组第一项的值
- splice(下标，删除数量)：从下标位置开始，删除指定数量的数据，返回一个新的数组，该数组记录了被删除的数据

### 其他操作

- 截取 slice(起始位置下标，结束位置下标)：从起始位置到结束位置之间的数据拿出来，得到一个新数组，该函数不会改变原数组

下标如果是负数，则从数组末尾往前数

如果不写结束下标，则直接取到末尾

- 清空数组

arr.splice(0, arr.length)

arr.length = 0

arr = []

- 查找数组中的某一项的下标

arr.indexOf(数据) 从数组中依次查找对应的数据，查找时使用严格相等进行比较，找到第一个匹配的下标，返回，如果未找到，返回-1

arr.lastIndexOf(数据) 从数组中查找出数据最后一次出现时的最后一个下标

- arr.fill(数据)：将数组的所有项，填充为指定的数据

arr.fill(数据, 开始下标)：将数组从指定的下标起，到数组的末尾，填充为指定的数据

arr.fill(数据, 开始下标, 结束下标)：将数组从指定的下标起，到数结束下标的位置(不包含结束下标)，填充为指定的数据

arr.join(分隔符)  Array -> String

## 7. 函数语法

typeof 函数名 = 'function'

## 8. 作用域和闭包

### 作用域

作用域表示一个代码区域，也表示一个运行环境

JS中，有两种作用域：

1. 全局作用域

直接在脚本中书写的代码

在全局作用域中声明的变量，会被提升到脚本块的顶部，并成为全局对象的属性

2. 函数作用域

函数中的代码

在函数作用域中声明的变量，会被提升到函数的顶部，并且不会成为全局对象的属性，因此，函数中声明的变量不会导致全局变量的污染。

尽量把功能封装在函数中

但是，当函数成为一个表达式时，它既不会提升，也不会污染全局变量。

将函数变成一个函数表达式的方法之一，是将函数用小括号括起来。立即执行函数

### 作用域中可以使用的变量

全局作用域只能使用全局作用域中声明的变量（包括函数）

函数作用域中不仅能使用自身作用域中声明的变量（包括函数），还能使用外部环境中的变量和函数

有些时候，某个函数比较复杂，在编写的过程，可能需要另外一些函数来辅助它完成一些功能，而这些函数仅仅会被该函数使用，不会在其他位置使用，则可以将这些函数声明到该函数的内部。

### 闭包

闭包(closure)，是一种现象，内部函数，可以使用外部环境中的变量

### 函数表达式

JS中，函数也是一个数据，语法上，函数可以用于任何需要数据的地方

JS中，函数是一等公民

函数是一个引用类型，将其赋值给某个变量时，变量中保存的是函数的地址

### 构造函数

```js
new 函数名(参数)
```

构造函数专门用于创建函数

1) 函数名使用大驼峰命名法

2) 构造函数内部，会自动创建一个新对象，this指向新创建的对象，并且自动返回新对象

3) 构造函数中如果出现返回值，如果返回的是原始类型，则直接忽略；如果返回的是引用类型，则使用返回的结果

4) 所有的对象，最终都是通过构造函数创建的

### new.target

该表达式在函数中使用，返回的是当前的构造函数，但是，如果该函数不是通过new调用的，则返回undefined

通常用于判断某个函数是否是通过new在调用。

### 函数的本质

函数的本质就是对象

所有的函数都是通过```new Function```创建

> Function

由于函数本身就是对象，因此函数中，可以拥有各种属性。

### 包装类

JS为了增强原始类型的功能，为boolean、string、number分别创建了一个构造函数：

1. Boolean

2. String

3. Number

如果语法上将原始类型当做对象使用时（一般在使用属性时），JS会自动在该位置利用对应的构造函数，创建对象来访问原始类型的属性。

> 类：在JS中，可以认为类就是构造函数，但在其他语言(如JAVA)中不是

> 成员属性(方法)、实例属性(方法)：表示该属性是通过构造函数创建的对象调用的。

> 静态属性(方法)、类属性(方法)：表示该属性是通过构造函数本身调用的。

### 递归

在函数内部，直接或间接调用自身

要避免无限递归，无限递归会导致执行栈溢出

对比死循环

- 死循环不会报错，也不会导致执行栈溢出
- 无限递归会导致执行栈溢出

### 执行栈

任何代码的执行都必须有一个执行环境，执行环境为代码的执行提供支持

执行环境是放到执行栈中。

每个函数的调用，都需要创建一个函数的执行环境，函数调用结束，执行环境销毁。

执行栈有相对固定的大小，如果执行环境太多，执行栈无法容纳，会报错

### 尾递归

如果一个函数最后一条语句是调用函数，并且调用函数不是表达式的一部分，则该函数称之为尾递归。

某些语言或执行环境会对尾递归进行优化，他们会立即销毁当前函数，避免执行栈空间被占用。

## 9. 标准库（标准API）

- 库(liberary)
- API：应用程序编程接口，Application Programing Interface

### Object

#### 静态成员

- Object.keys(某个对象)，得到某个对象的所有属性名数组
- Object.values(某个对象)，得到某个对象的所有属性值数组
- Object.entries(某个对象)，得到某个对象所有属性名和属性值的数组

#### 实例成员

> 实例成员可以被重写

**所有对象，都拥有Object的所有实例成员**

- Object.toString()，得到某个对象的字符串格式

默认情况下，该方法返回"[Object Object]"

- Object.valueOf()，得到某个对象的值

默认情况下，返回该对象本身

在JS中，当自动进行类型转换时，如果要对一个对象进行转换，实际上实现调用对象的valueOf方法，然后调用对象的toString方法，将得到的结果进行进一步转换。

### Function

**所有函数都具有Function中的实例成员**

#### 实例成员

- length属性，得到函数形参数量
- apply方法：调用函数，同时指定函数中的this指向，参数以数组的形式传入
- call方法：调用函数，同时指定函数中的this指向，参数以列表形式传入
- bind方法：得到一个新函数，该函数中的this始终指向指定的值

通常，可以利用apply、call方法，将某个伪数组转换成真数组。

### Array构造器

凡是通过Array构造函数创建的对象，都是数组

#### 静态成员

Array.from(arr) 将一个伪数组转换为一个真数组

Array.isArray(arr) 判断传入的值是否为真数组

#### 实例成员

- fill方法：用某个数据填充数组
- pop 末尾删除
- push 末尾添加
- reverse 颠倒数组顺序
- shift 首位删除
- sort 排序
- splice
- unshift

纯函数、无副作用函数： 不会导致当前对象发生改变

- concat
- join
- slice
- includes：数组中是否包含满足条件的元素，如果有两个参数，第二个参数表示从第几个下标开始找
- indexOf
- lastIndexOf
- forEach
- every: 数组中是否所有元素都满足
- some: 数组中是否至少有一个元素满足
- filter：过滤，返回一个满足条件的元素组成的数组
- map：映射，将数组中的每一项映射成另外一项，返回一个新数组
- reduce：统计，累计

### 原始类型包装器

- new 包装器(值):返回的是一个对象
- 包装器(值): 返回的是一个原始类型

#### Number

##### 静态成员

- Number.isNaN
- Number.isFinite
- Number.isInteger: 判断一个数据是否为整数
- Number.parseFloat: 将一个数据转换为小数
- Number.parseInt: 将一个数据转换为整数

parseInt、parseFloat要求参数是一个字符串，如果不是字符串，则会先转换为字符串。
从字符串开始位置进行查找，找到第一个有效的数字进行转换，如果没有找到，则返回NaN，左右空白字符会被忽略。

parseInt，可以传入第二个参数，表示将给定的字符串，识别为多少进制。

##### 实例成员

- toFixed 
- toPrecision: 以指定的精度返回一个数字字符串

#### Boolean 

#### String

##### 静态成员
- String.fromCharCode() 通过一串Unicode创建字符串

##### 实例成员
- length 字符串长度 （字符串是一个伪数组）
- charAt 返回指定位置的字符
- charCodeAt 返回表示给定索引的字符的Unicode的值
- concat
- includes
- endsWith
- startsWith
- indexOf
- lastIndexOf
- padStart
- padEnd
- repeat
- slice：从某个位置取到某个位置，位置可以是负数
- substr：从某个位置开始取，取指定的长度，位置可以是负数
- substring：从某个位置取到某个位置，位置不可以是负数，参数位置可以调换
- toLowerCase
- toUpperCase
- split：分割字符串

#### Math对象
- random
- PI 得到圆周率
- abs 求绝对值
- floor 向下取整
- ceil 向上取整
- max 得到一组数字的最大值，不传参，得到 -Infinity
- min 得到一个数组的最小值，不传参，得到 Infinity
- pow 求一个数字的幂次方
- round 四舍五入

#### Date构造函数

##### 创建时间对象
- 直接调用函数(不使用new)，忽略所有参数，直接返回当前时间的字符串
- new Date(): 创建日期对象

1. 无参，当前时间
2. 1个参数，参数是数字，表示传入的是时间戳
3. 两个参数以上，分别表示：年、月、日、时、分、秒、毫秒

注意：月份的数字从0开始计算

如果缺失参数日期部分默认为1，时分秒毫秒默认为0

##### 实例成员

- getDate：返回日期对象的月份中的第几天（1 - 31）
- getUTCDate
- getDay：返回指定日期对象的星期中的第几天（0 - 6）
- getFullYear：返回年份
- getMonth：返回月份，从 0 开始
- getHours：返回小时
- getMinutes：返回分钟
- getSeconds：返回秒
- getMilliseconds：返回毫秒
- getTime：返回时间戳

- setDate：设置日期对象的月份中的第几天（1 - 31）
- setUTCDate
- setDay：设置指定日期对象的星期中的第几天（0 - 6）
- setFullYear：设置年份
- setMonth：设置月份
- setHours：设置小时
- setMinutes：设置分钟
- setSeconds：设置秒
- setMilliseconds：设置毫秒
- setTime：设置时间戳

- toDateString：将日期部分转换为可读的字符串
- toISOString：将整个对象转换为ISO标准的字符串格式
- toLocaleDateString：根据当前系统的地区设置，将日期部分转换为可读的字符串
- toLocaleString：根据当前系统的地区设置，将整个日期转换为可读的字符串
- toLocaleTimeString：根据当前系统的地区设置，将时间部分转换为可读的字符串
- toUTCString：将日期转换为以UTC计时的字符串

### 原型和原型链

- 所有对象都是```new 函数```创建
- 所有函数都是对象
    - 函数中可以有属性
- 所有对象都是引用类型

#### 原型 prototype
所有函数都有一个属性：prototype，称之为函数原型

默认情况下，prototype是一个普通的Object对象

默认情况下，prototype中有一个属性，constructor，它也是一个对象，它指向构造函数本身

#### 隐式原型 __proto__

所有的对象都有一个属性：__proto__，称之为隐式原型

默认情况下，隐式原型指向创建对象的函数的原型

当访问一个对象的成员时：
1. 看该函数自身是否拥有该成员，如果有直接使用
2. 看该对象的隐式原型是否拥有该成员，如果有直接使用
3. 在原型链中依次查找

猴子补丁：在函数原型中加入成员，以增强对象的功能，会导致原型污染，使用时需谨慎

#### 原型链

特殊点：
1. Function的__proto__指向自身的prototype
2. Object的prototype的__proto__指向null

### 属性描述符

表达了一个属性的相关信息（元数据），它本身是一个对象。

1. 数据属性
2. 存取器属性
    1. 当给它赋值，会自动运行一个函数
    2. 当获取它的值时，会自动运行一个函数

Object.defineProperty(obj, propName, {
    <!-- 属性描述符 -->
    <!-- value -->
    <!-- get: function(){ return xx } -->
    <!-- set: function(val){} -->
})
