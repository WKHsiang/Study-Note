## 响应式
1. vue 响应式原理：
    Object.defineProperty 数据劫持 （待深入研究）

2. vm.$nextTick & Vue.nextTick
Dom更新后会立即执行
vue的缺点，vue会等待主线程任务执行完，如果一直不执行完，会导致页面卡死

nextTick的实现源码中，会先判断是否支持微任务，不支持后，才会执行宏任务
- 优先顺序：Promise -> MutationObserver -> setImmediate -> setTimeout

3. 哪些数据被修改后不会渲染页面？
- 未被声明过的数据
- 未被渲染过的数据
- 利用索引值直接设置一个数组项时
- 修改数组的长度时
- 添加或删除对象

4. 如何响应式的更新数组和对象
- 更改数组：
    - 利用数组变异方法：push、pop、unshift、shift、splice、sort、reverse
    - 利用vm.$set/Vue.set实例方法 vm.$set(要改谁，改它的什么，改成什么)
    - 利用vm.$set或Vue.set删除数组中的某一项 vm.$delete(要删除谁的值，删除哪个)
- 更改对象
    - 添加利用vm.$set/Vue.set实例方法
    - 删除利用vm.$delete/Vue.delete方法

## 指令
1. v-pre 
- 跳过这个元素和他的子元素的编译过程，一些静态的内容不需要编译加这个指令可以加快编译

2. v-cloak 
- 这个指令保持在元素上直到关联实例结束编译，在简单项目中，当网速比较慢，网页还在加载vue.js，会导致vue来不及渲染，此时页面是显示出vue源代码，标签加上v-cloak，可以解决这种问题，解决屏幕闪动；但在大型、工程化的项目中(webpack、vue-router)只有一个空的div元素，元素中的内容是通过路由挂载来实现的，这是不需要v-cloak。

3. v-once
- 只渲染元素一次

4. v-if VS v-show
- 1. v-if是惰性的，若初始条件为假，则什么也不做，直到条件第一次变为真，才开始渲染条件块；v-show则不管初始条件，元素都会渲染，并且只是简单的基于CSS进行切换
- 2. v-if切换开销较大，v-show初始开销较大，故需频繁切换时使用v-show，不需频繁切换时使用v-if
- 3. v-show不支持`<template>`元素

5. v-on的修饰符
- 1. .stop 阻止事件冒泡
- 2. .prevent 阻止默认事件
- 3. .capture 事件捕获模式
- 4. .self 只当事件是从侦听器绑定的元素本身触发时才触发回调
- 5. .once 只触发一次回调
- 6. .passive
    - 设置addEventListener中的passive选项
    - 能够提升移动端的性能
    - 即使在触发触摸事件时，执行了一个空的函数，也会让页面卡顿。因为浏览器不知道监听器到底会不会阻止默认事件，所以浏览器要等到执行完整个函数后，才能决定是否要滚动页面。passive事件监听器，允许开发者告诉浏览器，监听器不会阻止默认行为，从而浏览器可以放心大胆的滚动页面，这样可以大幅度提升移动端页面的性能，因为据统计只有20%的触摸事件会阻止默认事件。

## 计算属性
当处理复杂逻辑时，应该使用计算属性

- 有时，能用计算属性解决的问题，使用方法同样可以解决，不过方法在每一次页面重新渲染时都会执行，而计算属性只会在其关联的数据改变时执行。

- 计算属性和方法的最本质的区别：
    - 计算属性是基于响应式依赖进行缓存的，计算属性的值一直存于缓存中，只要它依赖的data数据不改变，每次访问计算属性，都会立即返回缓存的结果，而不是再次执行函数。而方法则是每次触发重新渲染，调用方法将总会再次执行函数。计算属性可以节约开销。
- 计算属性除了可以写成函数之外，还可以写成一个对象
```javascript
computed: {
    fullName: {
        getter() {
            return 'xxx'
        },
        setter(val) { // 可选，利用此函数重新赋值没有用，并不会改变计算属性的值，计算属性只与绑定它的data有关联
            console.log(val)
        }
    }
}
```

## 侦听器
